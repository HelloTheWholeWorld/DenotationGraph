#!/usr/bin/perl

use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin";
use simple;

my $t0 = time();
$| = 1;
my $c = 0;

loadVPs($ARGV[0]);

my $file;

# load the root node for each caption - we'll search its children to find the leaf nodes of a given caption
my %root = ();
open($file, "$ARGV[2]/initial.rewrite");
while (<$file>) {
	chomp($_);
	my @ax = split(/\t/, $_);

	if ($#ax == 1) {
		$ax[2] = "";
	}

	if ($#ax == 2) {
		$c++;
		my $dt = time() - $t0;
		print "\r$c $dt";

		$root{$ax[0]} = plain($ax[2]);
	}
}
close($file);
print "\n";

# load the node index of the current denotation graph
$c = 0;
my %index = ();
my $i = 0;
open($file, "$ARGV[1]/expand.idx");
while (<$file>) {
	$c++;
	my $dt = time() - $t0;
	print "\r$c $dt";

	chomp($_);
	my @ax = split(/\t/, $_);
	if ($#ax == 0) {
		$ax[1] = "";
	}
	$index{$ax[1]} = $ax[0];
	if ($i <= $ax[0]) {
		$i = $ax[0] + 1;
	}
}
close($file);
print "\n";

# load the tree of the current denotation graph
# %links - the links (and the captions/rules that produces them)
# %subtree - a subtree of all of the links produced by a given caption
my %links = ();
my %subtree = ();
open($file, "$ARGV[1]/expand-tree.txt");
while (<$file>) {
	chomp($_);
	my @ax = split(/\t/, $_);
	my $x = shift(@ax);
	my $l = shift(@ax);
	my $y = shift(@ax);
	my $lid = "$x\t$l\t$y";

	if (not exists $links{$lid}) {
		$links{$lid} = {};
	}

	foreach (@ax) {
		my @ay = split(/\#/, $_);
		my $id = "$ay[0]#$ay[1]";
		if (not exists $subtree{$id}) {
			$subtree{$id} = {};
		}
		if (not exists $subtree{$id}->{$y}) {
			$subtree{$id}->{$y} = {};
		}
		$subtree{$id}->{$y}->{$x} = 1;
		$links{$lid}->{$_} = 1;
	}
}
close($file);

# load the chunking of the nodes in the denotation graph (solely for expanding)
my %chunk = ();
open($file, "$ARGV[1]/expand-chunk.txt");
while (<$file>) {
	chomp($_);
	my @ax = split(/\t/, $_);
	my $i = shift(@ax);
	my $c = shift(@ax);

	if (not exists $chunk{$i}) {
		$chunk{$i} = {};
	}
	$chunk{$i}->{$c} = {};
	foreach (@ax) {
		$chunk{$i}->{$c}->{$_} = 1;
	}
}
close($file);

# load the node to caption map (solely for expanding)
my %nodeCap = ();
open($file, "$ARGV[1]/expand-cap.map");
while (<$file>) {
	chomp($_);
	my @ax = split(/\t/, $_);
	my $i = shift(@ax);

	$nodeCap{$i} = {};
	foreach (@ax) {
		$nodeCap{$i}->{$_} = 1;
	}
}
close($file);

# potentially add a new node to the denotation graph
# this consists of adding the chunking information
# assigning it an index
# and adding it to the node-caption map
sub addNode {
	# see if we need to assign it a new index
	my $r = plain($_[0]);
	if (not exists $index{$r}) {
		$index{$r} = $i;
		$i++;
	}
	$r = $index{$r};

	# add the chunking information to the node
	if (not exists $chunk{$r}) {
		$chunk{$r} = {};
	}
	my $c = chunk($_[0]);
	if (not exists $chunk{$r}->{$c}) {
		$chunk{$r}->{$c} = {};
	}
	$chunk{$r}->{$c}->{$_[1]} = 1;

	# add the caption to the node's node-caption map
	if (not exists $nodeCap{$r}) {
		$nodeCap{$r} = {};
	}
	$nodeCap{$r}->{$_[1]} = 1;

	return $r;
}

# potentially add a new edge to the denotation graph
sub addLink {
	# make sure this isn't a looping edge
	if ($_[0] != $_[2]) {
		# add the edge + caption that generates the edge
		my $lid = "$_[2]\t$_[1]\t$_[0]";
		if (not exists $links{$lid}) {
			$links{$lid} = {};
		}
		$links{$lid}->{$_[3]} = 1;
	}
}

# load the original captions - pre- any sort of rewrite rules, but after normalization
# we're going to create a node for it, add ORIG links from some of the caption's nodes to it
# and add some edges from the original caption using the SVO extraction rules
$c = 0;
my %orig = ();
open($file, "$ARGV[1]/pre.final");
while (<$file>) {
	$c++;
	my $dt = time() - $t0;
	print "\r$c $dt";

	chomp($_);
	my @ax = split(/\t/, $_);

	# for the caption, we need to identify all of its leaf nodes
	# we start by using the root node (from initial.rewrite) and search its
	# children until we hit the leaves
	my %leaf = ();
	my %visit = ();
	my @q = ();
	push(@q, $index{$root{$ax[0]}});
	$visit{$q[0]} = 1;
	while ($#q >= 0) {
		my $n = shift(@q);
		my $k = 0;

		# get all the children of this node that are generated by the caption
		if (exists $subtree{$ax[0]} && exists $subtree{$ax[0]}->{$n}) {
			foreach (keys %{$subtree{$ax[0]}->{$n}}) {
				$k++;
				if (not exists $visit{$_}) {
					$visit{$_} = 1;
					push(@q, $_);
				}
			}
		}

		# if we have no children, then this is a leaf
		if ($k == 0) {
			$leaf{$n} = 1;
		}
	}

	# add the original caption as a node
	my $s = addNode($ax[2], $ax[0]);
	$orig{$ax[0]} = $s;
	# add ORIG edges from it to all of the leaf nodes
	foreach (keys %leaf) {
		addLink($_, "ORIG", $s, $ax[0]);
	}

	# next, get the SVO triples from the original caption
	my @ay = split(/ /, $ax[2]);
	my ($next, $prev) = breakSlash(\@ay, 1);
	my $c = countVPs($ax[0]);
	for (my $j = 0; $j < $c; $j++) {
		my ($subj, $vp, $dobj) = getVP(\@ay, $next, $prev, $ax[0], $j);

		# if one of the components is expected, but missing, skip
		# (this probably shouldn't happen - not printing out error messages atm, though)
		if ($vp == -2 || $dobj == -2 || $subj == -2) {
			next;
		}

		# find the beginning and end of the VP
		my $vpE = $vp;
 		my $drop = 0;

		if ($dobj != -1) {
			$vpE = $dobj;
		}

		# grab the simple sentence
		my @az = ();
		for (my $k = 0; $k <= $#ay; $k += $next->[$k]) {
			if ($k == $subj || ($k >= $vp && $k <= $vpE)) {
				for (my $l = 0; $l < $next->[$k]; $l++) {
					push(@az, join("/", @{$ay[$k + $l]}));
				}
			} else {
				$drop = 1;
			}
		}

		# if we've dropped anything, add a COMPLEX link
		# BUGBUG: we're not using COMPLEX-VERB if there's no subject
		# (was probably written before the COMPLEX-VERB edge existed)
		my $simpleN = $s;
		if ($drop == 1) {
			my $t = addNode(join(" ", @az), $ax[0]);
			addLink($t, "COMPLEX", $s, $ax[0]);
			$simpleN = $t;
		}

		# if there's a subject, make subject-verb phrase extraction links
		# the resulting nodes should already exist in the NP and VP sub-graphs
		my $vpN = $simpleN;
		if ($subj != -1) {
			@az = ();
			for (my $k = 0; $k <= $#ay; $k += $next->[$k]) {
				if ($k == $subj) {
					for (my $l = 0; $l < $next->[$k]; $l++) {
						push(@az, join("/", @{$ay[$k + $l]}));
					}
				}
			}
			my $t = addNode(join(" ", @az),$ax[0]);
			addLink($t, "VERB", $simpleN, $ax[0]);

			@az = ();
			for (my $k = 0; $k <= $#ay; $k += $next->[$k]) {
				if ($k >= $vp && $k <= $vpE) {
					for (my $l = 0; $l < $next->[$k]; $l++) {
						push(@az, join("/", @{$ay[$k + $l]}));
					}
				}
			}
			$t = addNode(join(" ", @az), $ax[0]);
			addLink($t, "SUBJ", $simpleN, $ax[0]);
			$vpN = $t;
		}

		# if there's a direct object, extract the direct object
		# BUGBUG: missing DOBJ edge/verb extraction
		# (again, edge may not have existed when this was initially written)
		if ($dobj != -1) {
			@az = ();
			for (my $k = 0; $k <= $#ay; $k += $next->[$k]) {
				if ($k == $dobj) {
					for (my $l = 0; $l < $next->[$k]; $l++) {
						push(@az, join("/", @{$ay[$k + $l]}));
					}
				}
			}
			my $t = addNode(join(" ", @az), $ax[0]);
			addLink($t, "TVERB", $vpN, $ax[0]);
		}
	}
}
close($file);
print "\n";

# output the new data structures - this should be the final version of the denotation graph
print "Node Index\n";
open($file, ">$ARGV[2]/node.idx");
foreach (sort { $index{$a} <=> $index{$b} } keys %index) {
	print $file "$index{$_}\t$_\n";
}
close($file);

print "Node-Caption Map\n";
open($file, ">$ARGV[2]/node-cap.map");
foreach (sort { $a <=> $b } keys %nodeCap) {
	print $file "$_\t", join("\t", sort keys %{$nodeCap{$_}}), "\n";
}
close($file);

print "Graph\n";
open($file, ">$ARGV[2]/node-tree.txt");
foreach (keys %links) {
	print $file "$_\t", join("\t", sort keys %{$links{$_}}), "\n";
}
close($file);

print "Chunking\n";
open($file, ">$ARGV[2]/node-chunk.txt");
foreach my $x (sort { $a <=> $b } keys %chunk) {
	foreach (sort keys %{$chunk{$x}}) {
		print $file "$x\t$_\t", join("\t", sort keys %{$chunk{$x}->{$_}}), "\n";
	}
}
close($file);

print "Original Node List\n";
open($file, ">$ARGV[2]/cap-orig.map");
foreach my $cap (sort keys %orig) {
	print $file "$cap\t$orig{$cap}\n";
}
close($file);
