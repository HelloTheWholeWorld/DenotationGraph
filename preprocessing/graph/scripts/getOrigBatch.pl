#!/usr/bin/perl

# usage: getOrigBatch.pl <graph directory>

# map nodes produced by a caption to the actual original
# strings (including token IDs) of the caption

use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin";
use simple;
use Data::Dumper;

my $file;

# first, get all of the indicies generated by the caption
# hopefully it'll save us time during the later processing
#my %index = ();
#open($file, "$ARGV[0]/cap-node.map");
#while (<$file>) {
#	chomp($_);
#	my @ax = split(/\t/, $_);
	#if (shift(@ax) eq $ARGV[0]) {
#	my $capid = shift(@ax);
#        if (not exists $index{$capid}) {
#		$index{$capid} = {};
#	} 
#	foreach (@ax) {
#		$index{$capid}->{$_} = 1;
#	}
#}
#close($file);

# now get the actual strings for the indicies
my %string = ();
open($file, "$ARGV[0]/node.idx");
while (<$file>) {
	chomp($_);
	my @ax = split(/\t/, $_);
	#if (exists $index{$ax[0]}) {
#	$index{$ax[0]} = $ax[1];
	$string{$ax[1]} = $ax[0];
	#}
}
close($file);

# read the initial string + the rules
# @X - left side of rule
# @Y - right side of rule
# @dep - rule dependencies (we're going to null this out since we won't be tracking rules used)
# @type - label/type of the rules
# $init - initial original string
my %X = ();
my @X_temp = ();
my %Y = ();
my @Y_temp = ();
my %dep = ();
my @dep_temp = ();
my %type = ();
my @type_temp = ();
my %init = ();
my %cap_count = ();
open($file, "$ARGV[0]/initial.rewrite");
while (<$file>) {
	chomp($_);
	my @ax = split(/\t/, $_);
	if ($#ax == 1) {
		$ax[2] = "";
	}

	if ($#ax == 2) {
        my $cap_id = $ax[0] . '$0';
        if (exists $cap_count{$ax[0]}) {
            my $count = $cap_count{$ax[0]};
            $count = $count + 1;
            $cap_count{$ax[0]} = $count;
            $cap_id = $ax[0] . '$' . $count;
        }
        else {
            $cap_count{$ax[0]} = 0;
        }
		$dep{$cap_id} = [@dep_temp];
		$X{$cap_id} = [@X_temp];
		$Y{$cap_id} = [@Y_temp];
		$type{$cap_id} = [@type_temp];
		$init{$cap_id} = $ax[2];

		# reset the rules
		@X_temp = ();
		@Y_temp = ();
		@dep_temp = ();
		@type_temp = ();
	} elsif ($#ax == 4) {
		$dep_temp[$ax[0]] = "";
		$X_temp[$ax[0]] = $ax[2];
		$Y_temp[$ax[0]] = $ax[3];
		$type_temp[$ax[0]] = $ax[4];
	}
}
close($file);


# get the edges (+ the rules used to generate them)
my %links = ();
open($file, "$ARGV[0]/node-tree.txt");
while (<$file>) {
	chomp($_);
	my @ax = split(/\t/, $_);
	my $x = shift(@ax);
	shift(@ax);
	my $y = shift(@ax);

	foreach (@ax) {
		my @ay = split(/\#/, $_);
		my $id = $ay[0] . "#" . $ay[1];
		if ($#ay >= 2 && exists $type{$id}[$ay[2]]) {
			if (not exists $links{$id}) {
				$links{$id} = {};
			}
			if ($type{$id}[$ay[2]] =~ /^\+/) {
				if (not exists $links{$id}{$y}) {
					$links{$id}->{$y} = {};
				}
				$links{$id}->{$y}->{$ay[2]} = $x;
			} elsif ($type{$id}[$ay[2]] =~ /^-/) {
				if (not exists $links{$id}{$x}) {
					$links{$id}->{$x} = {};
				}
				$links{$id}->{$x}->{$ay[2]} = $y;
			}
		}
	}
}
close($file);

my %links_temp = ();
my $count = 0;
while(my($id, $init_temp) = each %init) {
    print "a $id\n";
    print "b $init_temp\n";
    my $orig_id = $id;
    my @temp = split(/\$/, $id);
    $id = $temp[0];
	if (exists $links{$id}) {
		%links_temp = %{$links{$id}};	
	}
	if (not exists $dep{$orig_id}) {
		print STDERR "$id has no rules\n";
		next;
	}
	@dep_temp = @{$dep{$orig_id}};
	#print join(", ",@dep_temp);
	@X_temp = @{$X{$orig_id}};
	#print join(", ",@X_temp);
	@Y_temp = @{$Y{$orig_id}};
	#print join(", ",@Y_temp);
	
    # generate the original strings of the caption's nodes
    # %visit - original strings we've already processed
    # @queue - our work queue (contains original strings to visit)
    # %orig - index -> original strings
    my %visit = ();
    my @queue = ();
    my %orig = ();

    push(@queue, $init_temp);
    $visit{$init_temp} = 1;
    while ($#queue >= 0) {
        my $q = shift(@queue);
        print "**".$q."\n";
        my $i = $string{plain($q)};
        print "*".plain($q)."\n";
        # match the original string and its index
        if (not exists $orig{$i}) {
            $orig{$i} = {};
        }
        $orig{$i}->{$q} = 1;

        # make the more navigable version of the string (used by applyRule)
        my @aq = split(/ /, $q);
        my ($qnext, $qprev) = breakSlash(\@aq, 1);

        # try applying each rule that we've seen for this node
        foreach my $rule (keys %{$links_temp{$i}}) {
            #print "rule ".$rule."\n";
            if (exists $X_temp[$rule]) {
                my $r = applyRule(\@aq, $qnext, $qprev, \@dep_temp, \@X_temp, \@Y_temp, $rule, {});
                #print "r ".$r;
                # if we generated a new original string that hasn't been visited before, add it to the queue
                if ($r ne "" && !exists $visit{$r}) {
                    push(@queue, $r);
                    $visit{$r} = 1;
                }
            }
        }
    }

    foreach my $i (sort {$a <=> $b} keys %orig) {
        foreach (keys %{$orig{$i}}) {
            print $id, "\t", $i, "\t", $_, "\n";
        }
    }
}
